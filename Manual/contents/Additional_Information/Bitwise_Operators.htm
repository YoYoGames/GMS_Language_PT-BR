<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Operadores Bitwise</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains how bitwise operators work" />
  <meta name="rh-index-keywords" content="Bitwise Operators" />
  <meta name="search-keywords" content="bitwise,bitwise operators" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Operadores Bitwise e Binários</h1>
  <p>No início da era do computador, o <strong>binário</strong> e o <strong>hexadecimal</strong> eram um modo de vida, provavelmente porque as línguas de alto nível (como o BASIC) eram simplesmente muito lentas para funcionar. Por exemplo, a multiplicação de 32 x 32 poderia ter levado
    vários ciclos de CPU para conseguir utilizar o BASIC, mas com o binário é feito como uma única operação em um único ciclo de CPU.</p>
  <p>Hoje em dia, porém, mesmo com o poder de um PC básico, você não precisa mais se preocupar com isso e pode fazer as coisas do &quot;longo caminho&quot;, uma vez que a velocidade da máquina e sua construção mais complexa de CPU compensará quaisquer pequenas vindas isto
    abordagem tem. Esta é uma grande notícia, é claro, pois significa que você não precisa mais otimizar cada linha de código que você escreve, mas se este for o caso - você deveria realmente se importar com o binário?</p>
  <p>A resposta é definitivamente &quot;sim, você deve&quot;. Embora seja verdade que você ainda pode obter alguns aumentos de velocidade - e às vezes estes podem ser significativos - o uso de binários e hexágonos leva a uma melhor compreensão de como a CPU funciona e também pode levar à escrita
    melhor código, sendo capaz de embalar melhor os dados e tornando algumas tarefas muito mais simples. Esta página vai explicar um pouco sobre o que é binário, bem como como ele pode ser usado ao fazer seus jogos.</p>
  <p>Portanto, vejamos primeiro a teoria binária mais básica - como os números são criados. Dê uma olhada nesta tabela:</p>
  <p class="code">000 = 0<br> 001 = 1<br> 010 = 2<br> 100 = 4</p>
  <p>Cada 1 ou 0 representa um único <a class="glossterm" data-glossterm="bit" href="#">bit</a> de dados, e como você pode ver isso significa que em binário, 10 é igual a 2! Cada bit é 2 vezes o valor anterior, sendo o primeiro bit igual a 1. Portanto, bit 2 = 2,
    bit 3 = 4, bit 4 = 8 e assim por diante (como mostrado abaixo nesta tabela de <a class="glossterm" data-glossterm="byte" href="#">bytes</a> ):</p>
  <p class="code">00000001 = 1<br> 00000010 = 2<br> 00000100 = 4<br> 00001000 = 8<br> 00010000 = 16<br> 00100000 = 32<br> 01000000 = 64<br> 10000000 = 128</p>
  <p>Tudo bem se você quer números que são um poder de 2, mas como criar números mais complexos? Bem, um único número binário só pode armazenar um 0 ou 1, e é isso, então para números mais complexos precisamos adicionar bits juntos. Se, por exemplo, nós
    quisemos fazer 6, somaríamos 4 e 2 juntos assim.</p>
  <p class="code">00000010 = 2<br> 00000100 = 4<br> 00000110 = 6</p>
  <p>Isto é verdade para <strong>todos os </strong>números binários, e como o computador compõe qualquer número internamente. Tomemos um número um pouco mais complicado como mais um exemplo: 23. O número 23 é na verdade composto de <span class="inline">1+2+4+16</span> ou <span class="inline">00010111</span>. Que tal um exemplo muito mais complexo: 196? Bem, isso é feito a partir de <span class="inline">128+64+4</span> ou <span class="inline">11000100</span>. Então, na verdade, não é tão complexo assim!</p>
  <p>Se começarmos a fazer valores fora do intervalo de um byte (que pode armazenar números de 0 a 255), começa a ser um pouco mais difícil de rastrear, no entanto. Por exemplo, 217.361 é <span class="inline">110101000100010001</span> em binário. Ou, <span class="inline">1+16+256+etc...</span> As regras são as mesmas, não importa qual seja o valor expresso - cada número é criado a partir da adição de vários bits juntos.</p>
  <p>Agora, como realizamos operações matemáticas sobre estes valores? Digamos que você queira armazenar <span class="inline">true</span> ou <span class="inline">false</span> como um valor. Normalmente os compiladores usarão um <span class="inline">INT</span> (um
    <span class="inline">INT</span> é geralmente definido como um número assinado de 32 bits - assinado significa apenas que pode ser um valor positivo ou negativo, enquanto que não assinado significa que só pode ser positivo) e depois simplesmente atribuí-lo a <span class="inline">0</span> ou <span class="inline">1</span>.
      Tendo apenas 2 estados, um valor <span class="inline">true</span> / <span class="inline">false</span> é ideal para armazenar em um bit, e se fizéssemos isso poderíamos armazenar 32 bits <span class="inline">true</span> / <span class="inline">false</span> para cada
      <span class="inline">INT</span> em vez de apenas um, já que um <span class="inline">INT</span> é composto de 32 bits.</p>
  <p>Como faríamos isso? Bem, é muito fácil:</p>
  <p class="code">bandeiras = bandeiras | 1;</p>
  <p>O operador &quot;<span class="inline">|</span>&quot; é um pouco <span class="inline">OR</span>, e isso significa a instrução acima <span class="inline">ORs</span> 1 no valor mantido na variável <span class="inline">flags</span>. Se você
    lembre-se de antes, usando um 1 irá definir o primeiro bit. Se quiséssemos definir o segundo bit, o faríamos:</p>
  <p class="code">bandeiras = bandeiras | 2;</p>
  <p>Nós <span class="inline">OR</span> em 2, porque o padrão de bits <span class="inline">00000010</span> é igual a 2. Então o que faz exatamente o operador do binário <span class="inline">OR</span>? Bem, ele funde todos os bits em um único valor,
    assim:</p>
  <p class="code">010110100 // Valor 1<br> 110011001 // valor 2<br> 110111101 // Valor 1 OU Valor 2</p>
  <p>Aqui está o que é conhecido como <a class="glossterm" data-glossterm="tabela da verdade" href="#">tabela</a> da verdade <a class="glossterm" data-glossterm="tabela da verdade" href="#">para o</a> operador OR:</p>
  <p class="code">00 | 00 = 00<br> 00 | 01 = 01<br> 01 | 01 = 01<br> 01 | 00 = 01</p>
  <p>Assim, onde há um valor com 2 zeros, ele permanecerá zero. A vantagem de usar bits como este como um estado <span class="inline">true</span>/<span class="inline">false</span>, é que eles podem definir vários bits como &quot;bandeiras&quot; em uma única operação,
    algo que você simplesmente não conseguiria fazer com um valor booleano normal. Por exemplo, digamos que o bit 1 é uma bandeira &quot;ativa&quot;, e o bit 3 é uma bandeira &quot;visível&quot;. Poderíamos definir ambos ao fazer isto:</p>
  <p class="code">bandeiras = bandeiras | 5<span class="inline"></span>;</p>
  <p>Isto porque 5 é <span class="inline">00000101</span> em binário, e seguindo a regra acima, a variável &quot;bandeiras&quot; fará com que ambos os 2 bits se fundam com seus próprios. Portanto, mesmo que o bit 1 já tenha sido definido, a operação ainda funciona e o bit 3 irá
    agora também ser definido.</p>
  <p>E quanto à limpeza das bandeiras? Bem, é aqui que entra a operação bitwise &quot;<span class="inline">&amp;</span>&quot; <span class="inline">AND</span>. Quando você <span class="inline">AND</span> algo, os bits que são colocados na máscara são mantidos,
    enquanto os pedaços que estão claros na máscara, são removidos - desta forma:</p>
  <p class="code">0111001010101 // Valor 1<br> 00110000100 // Valor 2<br> 00110000100 // Valor 1 E valor 2</p>
  <p>Como você pode ver, onde há um 1 em cada valor, o 1 é mantido, e onde há uma mistura ou 0's e 1's estes são zerados para 0. Aqui está a tabela da verdade para <span class="inline">AND</span>ing:</p>
  <p class="code">00 &amp; 00 = 00<br> 01 &amp; 00 = 00<br> 00 &amp; 01 = 00<br> 01 &amp; 01 = 01</p>
  <p>Portanto, somente quando há um pouco em cada lugar é que ele será mantido. O que isto significa, é que assim como você é capaz de colocar várias bandeiras ao mesmo tempo, você também pode retirar várias bandeiras de uma só vez. Por exemplo, tomemos o caso acima, mas desta vez as limpemos.
    Queremos limpar os bits 1 e 3 (dando-nos o valor 5), mas ao lembrar a tabela da verdade acima, o que queremos fazer é manter todos os outros bits, e limpar os bits 1 e 3. Esta seria uma &quot;máscara&quot; binária de 111111111111111111111111111111111010 (32bits).
    Esta máscara mantém todos os bits definidos atualmente, mas limpa os dois bits que realmente queremos que sejam limpos. Portanto, se tivesse um valor de 1000111011 e eu quisesse limpar os bits 1 e 3 usando a máscara acima, acabaria assim...</p>
  <p class="code">00000000000000000000001000111011 // Valor<br> 11111111111111111111111111111010 // Máscara<br> 00000000000000000000001000111010 // Valor E Máscara</p>
  <p>Isto é ótimo, mas se tivéssemos que resolver isto sempre que precisássemos limpar bandeiras, isto se tornaria cansativo. O que precisamos é de uma maneira de virar as bandeiras facilmente (e de preferência sem custo de CPU). Felizmente, há uma maneira fácil de fazer isso usando o &quot;
    <span class="inline">~</span> &quot; <span class="inline">NOT</span> operador.</p>
  <p>O operador <span class="inline">NOT</span> é apenas o que diz - <em>não</em> esses bits. Aqui está uma tabela da verdade para <span class="inline">NOT</span>.</p>
  <p class="code">~00 = 11<br> ~01 = 10<br> ~10 = 01<br> ~11 = 00</p>
  <p>Este operador torna a remoção de bandeiras muito simples, e melhor ainda, normalmente é uma otimização do tempo de compilação, ou seja, se você estiver usando um número constante (ou seja, não uma variável), então o compilador irá virar os bits automaticamente para você. Tome esta afirmação
    onde queremos limpar novamente os bits 1 e 3:</p>
  <p class="code">a = a &amp; ~5;</p>
  <p>Na verdade, isto se resumirá a apenas &quot;<span class="inline">a &amp; 11111111111111111111111111111010</span>&quot;. Isto torna a vida bastante simples em termos de limpeza de bandeiras.</p>
  <p>O último operador que queremos ver é &quot;<span class="inline">^</span>&quot; <span class="inline">EOR</span> (<span class="inline">Exclusive OR</span>, às vezes chamado <span class="inline">XOR</span>), este operador vira os bits definidos em ambos
    valores. Aqui está a tabela da verdade <span class="inline">EOR</span>:</p>
  <p class="code">0 ^ 0 = 0<br> 0 ^ 1 = 1<br> 1 ^ 0 = 1<br> 1 ^ 1 = 0</p>
  <p>Esta é uma curiosidade, mas incrivelmente útil. Por exemplo, digamos que queremos um contador que simplesmente conte de 0 a 1 e volte a 0 (alternando entre 0 e 1), poderíamos adicionar um e fazer um <span class="inline">IF</span> para ver se ele chegou a
    2 e, em seguida, reajustá-la para 1. Ou...poderíamos acrescentar 1 e depois <span class="inline">AND</span> com 1 (desde <span class="inline">01+01 = 10</span>, e <span class="inline">10 &amp; 01 = 0</span>) ou podemos fazer isso:</p>
  <p class="code">a = a ^ 1;</p>
  <p>O que isto faz na primeira vez que é executado é <span class="inline">0 ^ 1 = 1</span>, depois na segunda vez <span class="inline">1 ^ 1 = 0</span>, alternando assim as coisas de 0 para 1.</p>
  <p>Assim - <span class="inline">OR</span> (<span class="inline">|</span>), <span class="inline">AND</span>(<span class="inline">&amp;</span>), <span class="inline">NOT</span>(<span class="inline">~</span>) e <span class="inline">EOR</span>(<span class="inline">^</span>)
    manipulemos os bits com relativa facilidade, permitindo-nos, no nível mais simples, controlar vários bits ao mesmo tempo. Obviamente podemos usar estas operações para outras coisas ao desenvolver nossos jogos, como mascarar sprites, fazer operações inteiras <span class="inline">MOD</span> (usando <span class="inline">AND</span>) ou fazer bons contadores de looping.</p>
  <p>Então, podemos fazer operações simples, mas vamos olhar para as coisas mais complexas, começando com a pergunta, como um computador acrescenta? Vejamos um exemplo muito simples: <span class="inline">1+1</span>.</p>
  <p class="code">00000001<br> 00000001
    <br> 00000010
  </p>
  <p>Assim como as adições normais, adicionamos números juntos e depois transbordamos para a coluna seguinte, mas ao contrário de uma adição decimal normal, só podemos ir de 0 a 1, não de 0 a 9. Portanto, adicionar um <span class="inline">1+1</span> significa que transbordamos para <span class="inline">10</span>.
    Portanto, vejamos um exemplo mais complexo.</p>
  <p class="code">01011011 = 91<br> 00101101 = 45<br> 10001000 = 136</p>
  <p>É obviamente mais difícil ver aqui, mas o transbordamento se estende até que não haja ninguém em uma coluna. Vale notar que os computadores só podem adicionar (ou subtrair, multiplicar ou dividir) 2 números ao mesmo tempo. Pegue <span class="inline">19 + 19 + 19</span>.
    Sendo humanos, podemos somar todos os 9 juntos, carregar os 2 e depois continuarmos! Mas os computadores não podem fazer isso - o que eles podem fazer é o seguinte:<span class="inline"> (19 + 19) + 19</span>. Portanto, eles farão cada cálculo em blocos de 2.</p>
  <p>Os cálculos binários que mais nos interessam como programadores são a multiplicação e a divisão. Os computadores só se multiplicam em 2s e, para fazer mais, ele separa um número, e depois adiciona todos os resultados juntos. Vamos pegar alguns muito simples
    exemplos em primeiro lugar. <span class="inline">4 * 2 = 8</span>. Agora, para multiplicar por 2 em binário, <em>deslocamos </em>todos os bits para a ESQUERDA por um. Assim:</p>
  <p class="code">00000100 * 2 = 00001000 = 8</p>
  <p>Todos os bits neste caso se moveram para a esquerda por um, fazendo-o passar do 3º bit, para o 4º, e mudando o valor de 4 para 8. Que tal um número maior?</p>
  <p class="code">101 = 01100101 * 2 = 11001010 = 202</p>
  <p>Mais uma vez, todos os bits se movem em um, e esse múltiplo por 2. Então, que tal um múltiplo por 4? Fácil, nós deslocamos tudo o que sobra por 2, em vez de um. Então, que tal 16, ou 128? Isto exigiria um deslocamento à esquerda de 4 bits, ou 7 bits respectivamente. Isto é incrivelmente
    útil; isso significa que podemos fazer multiplicações simples, simplesmente movendo bits de um lado para o outro. Para isso, usamos o operador do <strong>turno esquerdo</strong> <span class="inline">&lt;&lt;</span>. Aqui estão alguns exemplos:</p>
  <p class="code">00000001 &lt;&lt;&lt; 1 = 000000010 = 2<br> 00000001 &lt;&lt; 2 = 000000100 = 4<br> 00000001 &lt;&lt; 3 = 000001000 = 8<br> 00000001 &lt;&lt; 4 = 000010000 = 16<br> 00000001 &lt;&lt; 5 = 000100000 = 32<br> 00000001 &lt;&lt;&lt; 6 = 001000000 = 64<br> 00000001 &lt;&lt; 7 = 010000000 = 128<br> 00000001 &lt;&lt; 8 = 100000000 = 256</p>
  <p>Agora, além de ser muito útil para multiplicações rápidas/simples, também é muito útil para definir bits específicos, sem ter que descobrir o valor do bit. Digamos que queríamos definir o bit 27, que número é esse? (67108864, a propósito!), bem
    podemos usar a sintaxe acima para facilmente colocar bandeiras como esta:</p>
  <p class="code">a = a | (1 &lt; &lt;&lt; 27)</p>
  <p>Certo... então na verdade este seria o bit 26 da maneira como temos descrito as coisas até agora (como bits têm começado em um), mas na verdade... bits começam no bit 0, e vão para cima, não no bit 1. Assim, enquanto há 32 bits em um INTEGER, a faixa de bits
    de 0 a 31, e não de 1 a 32. Isto é realmente muito útil, pois agora podemos estabelecer constantes para números de bits.</p>
  <p>Portanto, digamos que o bit 27 é uma bandeira ativa, e o bit 0 é uma bandeira explosiva. Como podemos definir ambos?</p>
  <p class="code">ATIVO = 27;<br> BOOM = 0;<br> A = A | (1 &lt;&lt; ATIVO) | (1 &lt;&lt; BOOM);</p>
  <p>Isto pode parecer muito código, mas se estes números forem constantes, o compilador irá pré-compilar estas operações em um único valor para que acabemos com isto como código real.</p>
  <p class="code">A = A | 13421772;</p>
  <p>Limpar estes pedaços (como vimos acima) é simplesmente uma questão de usar o modificador NOT, como este:</p>
  <p class="code">A = A &amp; ~((1 &lt; &lt;&lt; ATIVO) | (1 &lt;&lt; BOOM))</p>
  <p>Assim, isto nos permite, felizmente, definir e limpar quaisquer pedaços que desejarmos, e também nos permite comprimir maciçamente as estruturas de dados. Comprimir estruturas de dados é uma coisa boa, porque se você usa menos memória, você obtém menos falhas de cache, e seu código simplesmente roda
    mais rápido. Colocando desta forma, o que é mais rápido, copiar 32Mb ou dados, ou 4Mb? Bem, muito claramente 4 é. Portanto, se você puder empacotar todas as suas bandeiras em um único acesso de memória, isto é bom!</p>
  <p>Agora, vamos dar uma rápida olhada em como você faz a divisão e por que ela será tão útil. A divisão é feita deslocando os bits <em>corretamente</em> usando o operador de <strong>turno certo</strong> <span class="inline">&gt;&gt;</span>. Vamos levar
    um número simples - 64 - e dividi-lo por 32:</p>
  <p class="code">64 / 32 = 01000000 &gt;&gt; 5 = 00000010</p>
  <p>Então lá você desloca o único bit para baixo em 5 (que é o número de turnos necessários para 32 - veja acima), o que nos dá 2. Mas o que acontece se houver outros bits aqui dentro? Bem, vamos dar uma olhada:</p>
  <p class="code">68 / 32 = 01000100 &gt;&gt; 5 = 00000010</p>
  <p>Então lá vai você.... É exatamente o mesmo. Os bits que deslocamos para baixo são simplesmente perdidos. Isto é realmente útil, porque ao dividir para baixo se precisarmos do restante, há uma maneira ainda mais fácil de obtê-lo, o que conseguiremos em um momento. Mas
    primeiro, vamos dar um exemplo prático. Eu tenho uma posição X e Y, e quero ter a quadrícula da grade que cai dentro, onde a grade tem 32x32 de tamanho. Este método permite armazenar objetos, colisões, bandeiras - todo tipo de coisas, e acessá-las.
    muito rapidamente. Por isso, aqui vamos nós:</p>
  <p class="code">var X_index = x &gt;&gt; 5;<br> var Y_index = y &gt;&gt; 5;<br> cell_data = mygrid[# X_index,Y_index];</p>
  <p>Então, e se quiséssemos o restante? Talvez este restante seja usado como algum tipo de bandeira de ordem ou algo assim. Seja qual for o motivo, conseguir um resto é tão simples quanto fazer um <span class="inline">AND</span>:</p>
  <p class="code">var restante = x &amp; 31<br> var X_Index = x &gt;&gt; 5;</p>
  <p>Agora, você deve ter notado que usamos várias linhas de código aqui (como é tão freqüentemente o caso), mas isto ainda é apenas um par de instruções muito rápidas. Mas por que o 31? Bem, como o bit 5 é 32, então todos os bits abaixo seriam 31, e isso é o
    máximo restante, de modo que é com isso que nós <span class="inline">AND</span> (poderíamos também usar <span class="inline">(1 &lt;&lt; 5) - 1</span> que faria <span class="inline">32 - 1 = 31</span>). Agora, se eu fizesse isso sem entender
    binário, pareceria assim:</p>
  <p class="code">var r = x mod 32;<br> var X_Index = piso(x / 32);</p>
  <p>Então por que isso é muito pior? Bem, para dividir por 32, temos que executar uma divisão de ponto flutuante - o que obviamente leva tempo, mas para fazer o <span class="inline">mod 32</span>, você tem realmente que fazer outra! Se estivéssemos fazendo isso
    em assembler, na verdade obtemos AMBOS valores em uma só divisão, mas você não obtém isto em idiomas de alto nível (bem... não muito frequentemente), e assim você tem que fazer todo o trabalho duas vezes. Isto se soma, especialmente se você estiver fazendo um loop apertado com muitos cálculos
    assim. O Integer divide usando o bit shifting, como mostrado acima, realmente ajuda a otimizar seu jogo.</p>
  <p>Uma vez que este pode ser um conceito bastante complexo de entender e depois aplicar a situações de programação do mundo real, você pode encontrar abaixo uma série de pequenos exemplos que poderiam ser aplicados a qualquer jogo feito com o <span class="notranslate">GameMaker Studio 2</span>.</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Alinhamento de telhas</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Os desenvolvedores do<span class="notranslate">GameMaker Studio 2</span> frequentemente usam a função <span class="inline">place_free()</span>, e então quando uma colisão é encontrada, tente mover lentamente o objeto para fora, ou loopando em torno de uma posição <span class="inline">x</span> ou <span class="inline">y</span> enquanto continua a executar essa função, ou usando a função <span class="inline">move_outside_all()</span>.</p>
    <p class="dropspot">Então, qual é a maneira mais rápida de fazer isso? Bem, se usarmos azulejos de potência de 2 adequados, então temos um método muito simples que também é rápido como um raio. Se estamos nos movendo corretamente, e nos movemos para um bloco de colisão, então como sabemos que tudo é
      alinhado a 32, então precisamos também alinhar o duende a um limite de 32 pixels - de preferência o da esquerda - para que o duende seja movido OUT of the collision. Isto é realmente fácil, conhecendo as regras que usamos acima para obter o restante, e conhecendo
      como obter o inverso dos bits, podemos simplesmente fazer isso:<br></p>
    <p class="code">x = x &amp; ~31;</p>
    <p class="dropspot">Isso mesmo, isso é TUDO o que é preciso para alinhar-se a um limite de 32 pixels. Ao alterar os 31 podemos nos alinhar a qualquer coisa que quisermos - desde que seja um poder de 2. (Isto é o equivalente a dividir por 32, depois multiplicar por 32, removendo assim
      as partes inferiores).</p>
    <p class="dropspot">Se quiséssemos nos alinhar à direita, então faríamos o acima, mas depois adicionaríamos 32 para movê-lo para o próximo ladrilho. Simples. Tudo isso torna todo o código de colisão monumentalmente mais rápido, e permite que você passe o tempo da CPU onde você realmente precisa.</p>
    <p class="dropspot"></p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Chaves e Portas</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Digamos que você tenha um nível com algumas portas, e uma chave para cada uma delas. Como você pode marcar facilmente uma chave para uma porta específica? Bem, normalmente você simplesmente atribuiria uma identificação para a chave e a porta. Então e se você quisesse uma chave para abrir 2 ou 3 portas? Fácil. Você usa uma MÁSCARA.
      A porta teria um único bit atribuído dessa forma:<br><br></p>
    <p class="code">door_id = 1; // 0001<br></p>
    <p class="dropspot">Os outros seriam algo parecidos:<br><br></p>
    <p class="code">door_id=2; // 0010<br>door_id=4; // 0100<br>door_id=8; // 1000<br>etc...<br></p>
    <p class="dropspot">Se quiséssemos a chave para abrir as portas 1 e 3, então a chave teria o valor MASK de 5 (que é 101 em binário). Se fizermos um <span class="inline">AND</span> disso, e ele sair &quot;não zero&quot;, então sabemos que a chave pode abrir a
      porta. Você também poderia ter chaves que não abrissem nada tendo uma MASK de 0. Veja o código abaixo para a verificação propriamente dita:</p>
    <p class="code">se ((key_id &amp; door_id) ! = 0)<br> {<br> opendoor();<br> }<br></p>
    <p class="dropspot"><br /></p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Contadores em looping</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">Digamos que queremos um simples contador de animação, indo de 0 a 15 (já que temos 16 quadros de animação). Normalmente você faria um incremento, e depois faria um cheque em <span class="inline">if</span> para embrulhar o número, mas para este exemplo, vamos
      usar o operador <tt>AND(&amp;)</tt>:</p>
    <p class="code">contador = (contador + 1) &amp; 15;</p>
    <p class="dropspot">Como 16 é um poder de 2, podemos reduzir esse número em 1 e usá-lo como máscara, que depois podemos usar para embrulhar nosso contravalor. Se o contador subir de 15 para 16, acabamos com o padrão de bits <span class="inline">10000</span>, e se <span class="inline">AND</span> que
      com 15 (padrão de bits <span class="inline">01111</span>) acabamos com <tt>00000</tt> (simplesmente zero). Isto significa que o código acima é útil para embrulhar valores dentro da faixa de uma potência de 2.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">Poder de 2 Verificação</a></p>
  <div class="droptext" data-targetname="drop-down3">
    <p class="dropspot">E se você quisesse verificar se algo era um poder de 2? Bem, aqui está um pequeno truque... Isto retornará <span class="inline">true</span> se o valor dado for um poder de 2:<br></p>
    <p class="code">função is_pow2(_val)<br> {<br> return _val &amp; (_val - 1)) == 0;<br> }</p>
    <p class="dropspot">Então, se tivéssemos o número 51 (<span class="inline">110011</span>) o que isso faz? Bem, obtemos isto... <span class="inline">110011 &amp; 110010</span>, o que obviamente nos deixa com <span class="inline">false</span>, pois sobram muitos pedaços
      depois do <span class="inline">AND</span>. Se tivéssemos 64 (<span class="inline">1000000</span>), então ele se torna este... <span class="inline">1000000 &amp; 0111111</span> que nos deixa 0, <em>então</em> é <span class="inline">true</span>.</p>
    <p class="dropspot"><br /></p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#">Alinhamento do índice</a></p>
  <div class="droptext" data-targetname="drop-down4">
    <p class="dropspot">Aqui está um rápido pedaço de código para alinhar à potência de 2 números. (1,2,4,8,16 e assim por diante). Isto pode ser muito útil para alocação de memória, ou certificar-se de escrever os dados nos limites adequados. Neste exemplo, <span class="inline">_val1</span> precisa ser
      alinhado a <span class="inline">_val2</span> bytes, onde <span class="inline">_val2</span> é uma potência de 2 números. Esta pequena função arredonda para cima até o próximo limite do número desejado.<br></p>
    <p class="code">função align_pow2(_val1, _val2)<br> {<br> return _val1 + (_val2 - 1)) &amp; ~(_val2 - 1);<br> }<br></p>
    <p class="dropspot"><br /></p>
    <p class="dropspot"><br /></p>
  </div>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Voltar: <a href="Additional_Information.htm">Informações adicionais</a></div>
        <div style="float:right">A seguir: <a href="Type_Tables.htm">Tabelas de tipo</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Todos os direitos reservados</span></h5>
  </div>
  <!-- KEYWORDS
Bitwise Operators
-->
  <!-- TAGS
bitwise_operators
-->

</body></html>