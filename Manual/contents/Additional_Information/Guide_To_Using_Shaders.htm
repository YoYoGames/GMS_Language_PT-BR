<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Guia para o uso de Shaders</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains how to set up and use shaders" />
  <meta name="rh-index-keywords" content="Guide To Using Shaders" />
  <meta name="search-keywords" content="shaders,shader,use shaders,shader guide,shader setup,shader examples,shader example" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Guia para o uso de <span class="notranslate">Shaders</span></h1>
  <p><span class="notranslate">Os shaders</span> são freqüentemente usados para criar belos efeitos gráficos nos jogos. Eles também estão entre os recursos mais avançados oferecidos pelo <span class="notranslate">GameMaker Studio 2</span>, portanto é necessário que você tenha uma compreensão básica de programação e de como funciona o <span class="notranslate">GameMaker Studio 2</span> 
    antes de começar a trabalhar com eles.</p>
  <p>Então, o que é um <span class="notranslate">sombreador</span>? Inicialmente eles foram criados para fornecer sombra para iluminação (daí o nome), mas agora são usados para produzir uma enorme variedade de efeitos. O código <span class="notranslate">Shader</span> é semelhante ao código normal, mas é (quase sempre) executado pela GPU, não
    a CPU. Esta diferença vem com seu próprio conjunto de regras e limitações, mas as cobriremos mais tarde.</p>
  <p>Cada <span class="notranslate">sombreador</span> é composto de dois componentes separados: um <strong> <span class="notranslate">sombreador de</span> </strong>vértice e um <strong> <span class="notranslate">sombreador de</span> </strong> fragmento (também chamado de <strong> <span class="notranslate">sombreador de</span></strong> pixel). Vamos começar com o <span class="notranslate">sombreador</span> de vértice. Cada duende é formado por um retângulo,
    mas os computadores gostam de desenhar triângulos, por isso esses retângulos são divididos em dois triângulos (às vezes chamados de <em>quadângulos</em>). Isto nos deixa com seis vértices (cantos) por duende, mas dois deles são o mesmo, então devemos nos preocupar apenas com quatro.
    Agora, imagine que temos um para loop que passa por cima de cada vértice e executa o código dentro do vértice <span class="notranslate">sombreado</span> para cada um. Isto nos permite mudar a posição e a cor do vértice antes de passá-lo para o <span class="notranslate">sombreador</span> do fragmento, uma vez que o <span class="notranslate">sombreador do</span> vértice é executado
    mais cedo.</p>
  <p>Eis como isso ficaria:</p>
  <p><img alt="Shader Vertices" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Vertices.gif">Para o <span class="notranslate">sombreador de</span> fragmentos, você pode imaginar o mesmo loop que antes, mas desta vez ele passa por cima de cada pixel em seu
    sprite, dando-lhe informações tais como localização e cor daquele pixel. Em seu código de <span class="notranslate">sombreador de</span> fragmento, você realiza operações e cálculos para determinar a cor desse pixel para obter o efeito desejado. Por exemplo, se você quiser que um <span class="notranslate">shader</span> faça
    seu duende seja preto e branco, então você calcularia qual tonalidade de cinza cada pixel precisa ser para criar o efeito.</p>
  <p>Seria algo parecido com isto:</p>
  <p><img alt="Shader Fragments" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Fragments.gif">A razão pela qual o código <span class="notranslate">Shader</span> é normalmente executado pela GPU é que ele é mais eficiente. As CPUs modernas normalmente têm
    entre dois a oito núcleos. Cada núcleo pode realizar uma tarefa de cada vez, portanto, aproveitando a vantagem de vários núcleos, podemos realizar tantas tarefas simultaneamente. Em contraste, as GPUs modernas podem realizar milhares, e até dezenas de milhares, de tarefas em execução
    ao mesmo tempo. Isto é útil para <span class="notranslate">os shaders</span> porque podemos executar o código <span class="notranslate">shader</span> de milhares de pixels ao mesmo tempo. A limitação é que só temos acesso ao estado inicial do duende, portanto não sabemos de nenhuma modificação feita.
    a outros pixels, já que ainda não podemos ter certeza de que o código foi executado neles.</p>
  <p class="note"><strong>NOTA</strong>: <span class="notranslate">GameMaker Studio 2</span> permite aos usuários escrever <span class="notranslate">shaders</span> em <strong>GLSL</strong> (OpenGL <span class="notranslate">Shader</span> Language), <strong>HLSL</strong> (High-level <span class="notranslate">Shader</span> Language, usado quando se trabalha com DirectX), e <strong>GLSL ES</strong> (um subconjunto de
    GLSL, que é comum em dispositivos móveis). Aqui estamos usando <strong>GLSL ES</strong> como a linguagem <span class="notranslate">shader</span>, já que é a que oferece a melhor compatibilidade entre as plataformas alvo. Geralmente esta é a que você sempre quer usar, a menos que você
    têm necessidades muito específicas e compreendem a limitação dos outros idiomas <span class="notranslate">sombreados</span>. A matemática e as técnicas devem ser semelhantes entre as três línguas, porém, exceto por algumas diferenças de sintaxe aqui e ali.</p>
  <p>O <span class="notranslate">sombreador de</span> vértices é executado primeiro, e como explicamos acima, ele trata de <strong>vértices</strong>. Ele é usado para calcular posições, normais e coordenadas de textura. Estes <span class="notranslate">sombreadores</span> não são particularmente úteis em 2D, uma vez que cada duende é normalmente
    um quadrado, mas pode ser usado para fazer algumas inclinações, escalas, etc... Torna-se muito mais útil em 3D para cálculos de iluminação e deformações da malha. Os <span class="notranslate">shaders de</span> fragmentos são muito mais interessantes e são o que será coberto principalmente aqui, uma vez que o fragmento
   <span class="notranslate">shader</span> é onde obtemos informações sobre nossas texturas e podemos ajustar a cor final de cada pixel em nossa imagem.</p>
  <p> </p>
  <h2>Variáveis de<span class="notranslate">Shader</span> </h2>
  <p>Se você criou um <span class="notranslate">shader</span> no <span class="notranslate">GameMaker Studio 2</span>, você deve ter notado as seguintes palavras-chave no <span class="notranslate">shader</span> padrão de <strong>passagem</strong>. Estas palavras-chave ajudam o <span class="notranslate">shader</span> a entender a finalidade e o escopo de cada variável:</p>
  <ul class="colour">
    <li><strong>Atributo</strong>: Estas são variáveis passadas pela OpenGL para o<span class="notranslate">sombreador de</span> <strong>vértices </strong>. Estas podem mudar por vértice e são somente leitura. Estas incluem informações tais como posição do vértice, coordenadas de textura, cor do vértice, e vértice
      normal.</li>
    <li><strong>Variável</strong>: Estas são variáveis usadas para passar dados entre o <strong>vértice </strong>e os<span class="notranslate">shaders de</span> <strong>fragmentos </strong>. Estão disponíveis para escrita no <span class="notranslate">sombreador de</span> vértice, mas são somente de leitura no <span class="notranslate">sombreador de</span> fragmento.</li>
    <li><strong>Uniforme</strong>: Estas são variáveis que mudam por objeto e são passadas pelo usuário para o <span class="notranslate">shader</span>. Elas podem ser usadas tanto no vértice quanto nos <span class="notranslate">shaders de</span> fragmentos, mas são somente de leitura.</li>
  </ul>
  <p>Você também verá o uso do vec <strong>como</strong> uma palavra-chave. Isto é usado para identificar uma variável vetorial no <span class="notranslate">sombreador</span> e logo você verá que vetores são muito importantes quando se trabalha com sombreadores <span class="notranslate">.</span> É por isso que eles são implementados como uma base
    digite em GLSL. Se você não estiver familiarizado com eles, eles são um termo matemático representado como uma matriz com apenas uma coluna. Na programação, geralmente os representamos como uma matriz onde o número de componentes corresponde à dimensão. Duas e três dimensões
    Os vetores são freqüentemente usados para posições, coordenadas de textura ou cores sem um canal alfa, enquanto os tetradimensionais são usados para cores com um canal alfa. Também podemos especificar se eles contêm booleanos, inteiros ou valores de ponto flutuante. O
    A sintaxe para declarar um vetor é esta:</p>
  <p class="code">vec2 primeiroVec; // Vetor bidimensional de flutuadores<br> vec3 segundoVec; // Vetor tridimensional de flutuadores<br> vec4 terceiroVec; // Vetor tridimensional de flutuadores<br>
    <br> bvec3 boolVec; // Vetor tridimensional de booleans<br> ivec4 intVec; // Vetor tridimensional de booleans</p>
  <p>Para inicializá-los, podemos usar o construtor para criar o vetor. É necessário fornecer o mesmo número de valores que o comprimento do vetor, mas é possível misturar e combinar escalares e vetores menores para atingir o comprimento alvo. Aqui estão alguns exemplos
    disto:</p>
  <p class="code">// Vetor 2D simples com 2 valores escalares<br> vec2 firstVec = vec2(2.0, 1.0);<br> // Um vetor 4D usando 2 escalares e um vec2 cria os 4 valores<br> vec4 secondVec = vec4(1.0, firstVec, 0.0);<br> // Um vetor 3D usando 1 componente de um vec4 mais um
    vec2 para criar os 3 valores<br> vec3 terceiroVec = vec3(segundoVec.x, primeiroVec);</p>
  <p>Também podemos atribuir-lhes outro vetor com o mesmo comprimento (ou <em>abanar </em>o vetor até que tenha o comprimento adequado, mas explicaremos isso em um momento):</p>
  <p class="code">vec3 primeiroVec;<br> vec3 segundoVec = primeiroVec;<br> vec4 terceiroVec = segundoVec.xyz;<br> vec2 quartoVec = terceiroVec.zx;</p>
  <p>Ao acessar componentes vetoriais na GLSL, temos algumas opções. A mais básica é tratar o vetor como uma matriz e acessar os componentes usando colchetes, como este:</p>
  <p class="code">vec4 myVec;<br> myVec[0] = 1.0;<br> myVec[1] = 0.0;<br> myVec[2] = 2.0;<br> myVec[3] = 1.0;</p>
  <p>Entretanto, há outra maneira de acessar os componentes com a seguinte sintaxe:</p>
  <p class="code">vec4 myVec;<br> myVec.x = 1.0;<br> myVec.y = 2.0;</p>
  <p>Isto usa os nomes dos componentes dentro do vetor para acessá-los. Pode-se usar x, y, z, ou w, para obter o primeiro, segundo, terceiro, ou quarto componentes, respectivamente. Referimo-nos a este método como <strong>suingue </strong>, porque a seguinte sintaxe também é
    válido:</p>
  <p class="code">vec4 primeiroVec;<br> vec3 segundoVec = primeiroVec.xyz;<br> vec2 terceiroVec = segundoVec.zy;<br> vec4 quartoVec = terceiroVec.yxxy;</p>
  <p>Como você pode ver, podemos usar qualquer combinação de até quatro letras para criar um vetor com esse comprimento. Não podemos tentar acessar um componente que esteja fora dos limites (por exemplo, tentando acessar w em <span class="inline">secondVec</span> ou
   <span class="inline">terceiroVec</span>, já que eles não têm um quarto componente). Também podemos repetir as letras e utilizá-las em qualquer ordem, desde que a variável vetorial à qual está sendo atribuída tenha o mesmo tamanho que o número de letras utilizadas.</p>
  <p>Por razões óbvias, ao usar swizzle para definir valores de componentes, não se pode usar o mesmo componente duas vezes. Por exemplo, o texto abaixo não é válido, pois você está tentando definir o mesmo componente para dois valores diferentes:</p>
  <p class="code">myVec.xx = vec2(2.0, 3.0);</p>
  <p>Por último, temos usado <span class="inline">xyzw</span> como nossa máscara swizzle, o que geralmente é o caso quando lidamos com posições. Há mais dois conjuntos de máscaras que você pode usar: <span class="inline">rgba</span> (usado para cores), ou <span class="inline">stpq</span> (usado para coordenadas de textura). Internamente, não há diferença entre estas máscaras, e as usamos apenas para tornar o código mais claro quanto ao que o vetor representa naquela instância. Além disso, não podemos combinar máscaras swizzle na mesma operação, portanto
    isto é inválido:</p>
  <p class="code"><span class="inline"></span>myVec = outrosVec.ybp;</p>
  <p>Essas foram muitas definições e informações, mas saber essas coisas é necessário para entender os próprios <span class="notranslate">shaders</span>.</p>
  <p> </p>
  <h2>Criando um <span class="notranslate">Shader</span></h2>
  <p>Quando você criar um <span class="notranslate">shader</span> no <span class="notranslate">GameMaker Studio 2</span>, ele abrirá dois arquivos para você: um <span class="notranslate">shader de</span> vértice (<span class="inline">.vsh</span>) e um <span class="notranslate">shader de</span> fragmento (<span class="inline">.fsh</span>). Este é o <span class="notranslate">shader</span> mais básico que você pode fazer, que leva um sprite,
    lê a textura, e coloriza cada pixel com essa cor. Se você especificar cores de vértices ao desenhar, essas cores se misturarão com a textura.</p>
  <p>Vamos analisar o código para um <span class="notranslate">shader</span> recentemente criado e analisá-lo, começando com o vértice <span class="notranslate">shader</span>.</p>
  <p class="code">// Passthrough Vertex <span class="notranslate">Shader</span><br> atributo vec3 in_Position; // (x,y,z)<br> // atributo vec3 in_Normal; // (x,y,z) não usado neste <span class="notranslate">shader</span>.<br> atributo vec4 in_Colour; // (r,g,b,a)<br> atributo
    vec2 in_TextureCoord; // (u,v)<br>
    <br> variação vec2 v_vTexcoord;<br> variação vec4 v_vColour;<br>
    <br> void main()<br> {
    <br> vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);<br> gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;<br>     <br> v_vColour = in_Colour;<br> v_vTexcoord = in_TextureCoord;<br> }
  </p>
  <p>Fora da função principal, vemos algumas declarações variáveis e seus qualificadores. Os atributos são-nos dados pelo <span class="notranslate">GameMaker</span>. As variáveis são criadas pelo usuário para passar essa informação para o <span class="notranslate">shader</span> do fragmento. Dentro da função principal,
    temos os cálculos para encontrar a posição da tela do vértice:</p>
  <ul class="colour">
    <li>Primeiro, criamos um <span class="inline">vec4</span> e o inicializamos com os componentes da posição, acrescentando um como quarto componente. Em álgebra linear, a convenção é que adicionamos um ao quarto componente se o vetor estiver representando
      um ponto, ou um zero se ele representar um vetor real.</li>
    <li>Em seguida, precisamos adicionar este quarto componente para multiplicá-lo com a matriz <span class="inline">MATRIX_WORLD_VIEW_PROJECTION</span>, que é uma matriz 4x4. Esta multiplicação projetará a posição mundial do vértice em coordenadas de tela.</li>
    <li>Finalmente, passamos a coordenada de cor e textura do vértice para o <span class="notranslate">sombreador</span> do fragmento através de nossas variáveis variáveis variáveis variáveis.</li>
  </ul>
  <p>Este <span class="notranslate">shader</span> deve ser deixado em paz se você não estiver planejando jogar com posições de vértices e não será usado em nenhum dos exemplos dados abaixo porque todos os efeitos mostrados serão criados usando o <span class="notranslate">shader de</span> fragmento.</p>
  <p>Vamos dar uma rápida olhada no <span class="notranslate">shader</span> do fragmento agora:</p>
  <p class="code">// Passthrough Fragment <span class="notranslate">Shader</span><br> variando vec2 v_vTexcoord;<br> variando vec4 v_vColour;<br>
    <br> void main()<br> {
    <br> gl_FragColor = v_vColour * textura2D( gm_BaseTexture, v_vTexcoord );<br> }
  </p>
  <p>Como explicado anteriormente, a idéia por trás de um fragmento de <span class="notranslate">sombreador</span> é devolver a cor do pixel atual. Isto é feito atribuindo à variável <span class="inline">gl_FragColor</span> o valor final da cor. A função <span class="inline">texture2D</span> 
    leva uma textura e um <span class="inline">vec2</span> com as coordenadas UV que você deseja verificar nessa textura, que retorna um <span class="inline">vec4</span> com a cor. Na passagem pelo <span class="notranslate">shader</span>, tudo o que estamos fazendo é agarrar a cor de
    a textura na coordenada deste pixel e multiplicando-a pela cor do vértice associado a este pixel.</p>
  <p>Agora que temos nosso primeiro <span class="notranslate">shader</span>, tudo o que temos que fazer para testá-lo é criar um objeto e atribuir-lhe um sprite, depois no <strong>Evento de Sorteio</strong> do objeto você define o <span class="notranslate">shader</span> desta forma:</p>
  <p class="code">// Evento de desenho<br> <span class="notranslate">shader_set</span>(shdrColorOverlay);
    <br> draw_self();
    <br> <span class="notranslate">shader_reset</span>();
  </p>
  <p>Cada chamada de sorteio que fizermos entre <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_set.htm"><span class="inline"><span class="notranslate">shader</span>_set()</a> e <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_reset.htm"><span class="inline"><span class="notranslate">shader</span>_reset()</a> irá
    ter o <span class="notranslate">sombreador</span> aplicado a ele. Aqui, estamos desenhando o objeto sprite com nosso <span class="notranslate">shader</span> passthrough:</p>
  <p><img alt="Drawing Sprite Using Passthough Shader" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_PassThrough.gif">Como você deve ter adivinhado, isto não muda nada visualmente, já que é uma simples passagem
   <span class="notranslate">shader</span>. Entretanto, as seções abaixo esboçam alguns passos simples que você pode tomar para modificar isto e mudar a maneira como o duende será desenhado. Cada seção mostra um <span class="notranslate">sombreador</span> diferente que você pode criar e usar em seus projetos, explicando os passos necessários
    para criá-las e porque estamos fazendo as coisas do jeito que estamos fazendo.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"> <span class="notranslate">Shader de</span>sobreposição de cores</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Agora podemos editar o <span class="notranslate">sombreador de</span> base para fazer algo diferente. Não tocaremos na parte do shader do vértice, e somente editaremos o shader do fragmento <span class="notranslate">,</span> e para começar, faremos uma operação muito simples, que é fazer com que o shader <span class="notranslate">desenhe</span> o duende.
      usando a cor vermelha. Faremos isso simplesmente mudando o <span class="inline">gl_FragColor</span> para ser vermelho, assim:</p>
    <p class="code">// Color Overlay Fragment <span class="notranslate">Shader</span><br> void main()<br> {
      <br> gl_FragColor = vec4(1.0, 0.0, 0.0, 0.0, 1.0);<br> }
    </p>
    <p class="dropspot">Isto nos dará o seguinte resultado:</p>
    <p class="dropspot"><img alt="Initial Colour Overlay Block" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_ColourOverlay_Block.gif">Não é exatamente o que esperávamos! O que precisamos lembrar é que cada duende é, em última análise, um retângulo,
      Portanto, a menos que consideremos a transparência - o que não temos - este é o resultado que teremos.</p>
    <p class="note"><strong>NOTA</strong>: Na imagem acima, o retângulo muda de tamanho porque o duende base teve o espaço &quot;vazio&quot; ao redor dele cortado automaticamente quando foi colocado na página de textura pelo GameMaker, <span class="notranslate">então cada</span> animação enquadra os triângulos
      que a compõem são tamanhos diferentes para se ajustar ao tamanho cortado da moldura. Se você desativar esta opção, então você simplesmente terá um quadrado vermelho sem movimento na tela.</p>
    <p class="dropspot">Acima mencionamos a função <span class="inline">texture2D</span>, e vamos usá-la para pegar a cor no pixel em que estamos trabalhando e obter a transparência do mesmo. O valor de retorno de <span class="inline">texture2D</span> é um
      <span class="inline">vec4</span> , onde os componentes são os vermelhos, verdes, azuis e alfa, nessa ordem. Podemos acessar o canal alfa colocando um período seguido por um <span class="inline">a</span> ou um <span class="inline">w</span> após o nome da variável. Isto corresponde a RGBA e XYZW, respectivamente.</p>
    <p class="dropspot">Aqui está o código atualizado:</p>
    <p class="code">// Color Overlay Fragment <span class="notranslate">Shader</span><br> variando vec2 v_vTexcoord;<br>
      <br> void main()<br> {
      <br> vec4 texColor = text2D(gm_BaseTexture, v_vTexcoord);<br> gl_FragColor = vec4(1.0, 0.0, 0.0, texColor.a);<br> }
    </p>
    <p class="dropspot">Estamos agora atribuindo um novo <span class="inline">vec4</span> para <span class="inline">gl_FragColor</span>, onde o canal vermelho é máximo, os canais verde e azul são zero, e o canal alfa é o mesmo que a textura original. A saída parece
      assim:</p>
    <p class="dropspot"><img alt="Overlay Shader Making Sprite Red" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_ColourOverlay.gif">Agora é isso que procurávamos! Substituímos a cor de cada pixel por vermelho, mas mantivemos
      o canal alfa intacto.</p>
    <p class="dropspot">Ter que mudar o <span class="notranslate">sombreador</span> cada vez que queremos usar uma cor diferente não é uma boa idéia, especialmente porque precisaríamos ter um <span class="notranslate">sombreador</span> separado para cada cor que queremos. Em vez disso, passaremos as informações de cor para o <span class="notranslate">sombreador</span> usando um <strong>uniforme</strong>.
      Para fazer isso, precisamos primeiro de um <strong>ponteiro </strong>para o uniforme. Faremos isso no <strong>evento Create Event</strong> de nosso objeto que tem o duende, acrescentando:</p>
    <p class="code">// Criar evento<br> _uniColor = <span class="notranslate">shader_get_uniform</span>(shdrColorOverlay, &quot;u_color&quot;);<br> _color = [1.0, 1.0, 0.0, 1.0, 1.0];</p>
    <p class="dropspot">Tudo que precisamos fazer é ligar para <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_get_uniform.htm"><span class="inline"><span class="notranslate">shader</span>_get_uniform()</a> para obter um ponteiro para o uniforme. Os parâmetros que precisamos passar são o <span class="notranslate">sombreador</span>
      nome do ativo (sem cotação porque queremos passar o ID que <span class="notranslate">o GameMaker</span> gera para nós) e o nome da variável uniforme dentro do <span class="notranslate">sombreador</span>, desta vez como uma corda. Este nome precisa corresponder exatamente ao que está dentro do código do <span class="notranslate">shader</span> para ele
      para trabalhar. Também adicionamos uma variável de cor para que possamos mudá-la em <span class="notranslate">tempo de execução</span> e fazer com que ela se lembre de nossas mudanças.</p>
    <p class="dropspot">Agora o código em nosso evento de sorteio será ligeiramente alterado para passar a variável uniforme.</p>
    <p class="code">// Evento de desenho<br> <span class="notranslate">shader_set</span>(shdrColorOverlay);
      <br> <span class="notranslate">shader_set_uniform_f_array</span>(_uniColor, _color);<br> draw_self();
      <br> <span class="notranslate">shader_reset</span>();
    </p>
    <p class="dropspot">É o mesmo código de antes, mas antes de desenharmos qualquer coisa, precisamos passar todos os valores uniformes para o <span class="notranslate">sombreador</span>. Neste caso, estamos passando a cor como uma matriz de flutuadores. Quanto ao <span class="notranslate">sombreador</span>, vamos mudá-lo para incluir o uniforme e usá-lo,
      assim se torna:</p>
    <p class="code">// Color Overlay Fragment <span class="notranslate">Shader</span><br> variação vec2 v_vTexcoord;<br> uniforme vec4 u_color;<br> void main()<br> {
      <br> vec4 texColor = text2D(gm_BaseTexture, v_vTexcoord);<br> gl_FragColor = vec4(u_color.rgb, texColor.a);<br> }
    </p>
    <p class="dropspot">Declaramos uma variável com o mesmo nome que no <span class="notranslate">shader</span> create (<span class="inline">u_color</span>) e a passamos como os três primeiros componentes do vetor <span class="inline">gl_FragColor</span>, aproveitando o swizzling. Se compilarmos
      novamente, devemos ver isto:</p>
    <p class="dropspot"><img alt="Overlay Shader Making Sprite Yellow" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_ColourOverlay_Yellow.gif">Agora o <span class="notranslate">sombreador</span> é muito mais útil e reutilizável. Cabe a você acrescentar mais funcionalidade
      se você precisar para definir a cor (usando a variável <span class="inline">_color</span>) durante <span class="notranslate">o tempo de execução</span>.</p>
    <p> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"> <span class="notranslate">Shader</span>Preto e Branco</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Fazer um <span class="notranslate">sombreador</span> preto e branco é uma ótima maneira de aprender mais sobre como funcionam <span class="notranslate">os sombreadores</span>, e muitos iniciantes começam tentando fazer isso, já que conceitualmente é bastante simples: pegar cada pixel e atribuir-lhe um tom de cinza. Mas será simples? Não
      bastante...
    </p>
    <p class="dropspot">Ao utilizar a cor RGB, se todos os três componentes tiverem o mesmo valor, então obtemos um tom de cinza. A abordagem ingênua para criar um <span class="notranslate">sombreador</span> para usar esta idéia seria adicionar os três canais de cor (vermelho, verde e azul) e depois dividi-lo por três. Depois de
      que você havia atribuído o valor aos três canais, criando assim um tom de cinza. Eis como se parece esse fragmento de <span class="notranslate">sombreador</span>:</p>
    <p class="code">// <span class="notranslate">Shader</span>fragmento preto e branco<br> variando vec2 v_vTexcoord;<br> variando vec4 v_vColour;<br>
      <br> void main()<br> {
      <br> vec4 texColor = text2D(gm_BaseTexture, v_vTexcoord);<br> float gray = (texColor.r + texColor.g + texColor.b) / 3.0;<br> gl_FragColor = v_vColour * vec4(gray, gray, gray, texColor.a);<br> }
    </p>
    <p class="dropspot">Uma coisa que você deve ter notado é que no código <span class="inline">gl_FragColor</span>, estamos multiplicando o <span class="inline">vec4</span> com algo chamado <span class="inline">v_vColour</span>. Esta é uma variável passada pelo
      vértice <span class="notranslate">shader</span> que nos diz a cor do vértice associado a este pixel. É sempre uma boa idéia multiplicar sua cor final calculada com a cor do vértice. Na maioria dos casos, ele não fará nada, mas se você mudou a cor do vértice no <span class="notranslate">GML</span>,
      isto refletirá que (utilizando funções como <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_ext.htm"><span class="inline">draw_sprite_ext()</span></a> ou <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_general.htm"><span class="inline">draw_sprite_general()</span></a> para
      mudar o <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/image_blend.htm"><span class="inline">image_blend</span></a>).</p>
    <p class="dropspot">Quanto ao evento do sorteio, é bastante simples, já que não temos um uniforme para passar:</p>
    <p class="code">// Evento de desenho<br> <span class="notranslate">shader_set</span>(shdrBlackAndWhite);
      <br> draw_self();
      <br> <span class="notranslate">shader_reset</span>();
    </p>
    <p class="dropspot">Vamos compilar e ver o que temos.</p>
    <p class="dropspot"><img alt="Black And White Shader" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_BlackAndWhite.gif">Isto já parece ótimo, certo? Bem, sim e não... há uma solução que é mais "correta", já que em vez disso
      de adicionar os componentes e dividir por três, multiplicamos cada componente pelos valores padrão do NTSC para preto e branco. Aqui está o código de <span class="notranslate">sombreamento</span> modificado do fragmento:</p>
    <p class="code">// <span class="notranslate">Shader</span>fragmento preto e branco<br> variando vec2 v_vTexcoord;<br>
      <br> void main()<br> {
      <br> vec4 texColor = text2D(gm_BaseTexture, v_vTexcoord);<br> float grey = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));<br> gl_FragColor = vec4(gray, gray, gray, texColor.a);<br> }
    </p>
    <p class="dropspot">Usamos o produto ponto como abreviação para multiplicar cada componente de <span class="inline">texColor</span> com os pesos corretos e depois os somamos juntos. Se você não está familiarizado com o produto ponto, isto é essencialmente o que está acontecendo:</p>
    <p class="code">float gray = (texColor.r * 0,299) + (texColor.g * 0,587) + (texColor.b * 0,114);</p>
    <p class="dropspot">No final, parece muito parecido, mas é tecnicamente mais correto.</p>
    <p class="dropspot"><img alt="Corrected Black And White Shader" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_BlackAndWhite_Improved.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Arco-íris <span class="notranslate">Shader</span></a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">Nosso último exemplo de <span class="notranslate">sombreamento</span> é divertido e pode ser usado para dar vida a textos, botões e outras coisas. Vamos começar simples e adicionar funcionalidade gradualmente, uma vez que este shader <span class="notranslate">é</span> altamente personalizável. Há muito a ser coberto por este aqui,
      Portanto, se você se sentir um pouco perdido ou confuso, por favor, volte atrás e releia algumas das seções acima.</p>
    <p class="dropspot">A primeira coisa que queremos fazer é colorir os pixels com cada tonalidade, dependendo da posição horizontal do pixel. A maneira de fazer isso é definir a posição x para ser a matiz e depois converter do formato HSV (matiz, saturação, brilho) para RGB (vermelho, verde),
      e azul) formato. Para isso, precisaremos escrever uma função auxiliar em nosso fragmento de <span class="notranslate">sombreador</span> que leva valores HSV e retorna um vetor RGB. Usaremos uma única função que faz isso sem a necessidade de qualquer declaração em <span class="inline">if</span>,
      pois o uso de condicionadores em código de <span class="notranslate">sombreamento</span> torna <span class="notranslate">os sombreadores</span> <em>muito </em>lentos, e deve ser evitado.</p>
    <p class="dropspot">Aqui está como é o <span class="notranslate">sombreador</span> nesta fase:</p>
    <p class="code">// Fragment <span class="notranslate">Shader</span><br> variação vec2 v_vTexcoord;<br> variação vec4 v_vColour;<br>
      <br> vec3 hsv2rgb(vec3 c) <br> {
      <br> vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br> vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br> return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br> }
      <br>
      <br> void main()<br> {
      <br> vec3 col = vec3(v_vTexcoord.x, 1.0, 1.0);<br> float alpha = textura2D(gm_BaseTexture, v_vTexcoord).a;<br> gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br> }
    </p>
    <p class="dropspot">Há um pouco mais acontecendo aqui do que nos exemplos anteriores, mas a maior parte deve ser bastante óbvia para você agora. Primeiro, há a nossa função <span class="inline">hsv2rgb</span>, que leva um <span class="inline">vec3</span> com nossa cor HSV
      e retorna outro <span class="inline">vec3</span> com nossa conversão RGB. Na função principal, começamos criando nossa cor HSV, onde a tonalidade é nossa posição x, e deixaremos a saturação e o brilho como 1,0 por enquanto. Então, obtemos
      o alfa da textura, de modo que ele apenas colore nosso personagem duende e não todo o retângulo duende (como fizemos no exemplo da sobreposição de cores, acima). Finalmente, definimos nossa cor Fragmento para ser nossa cor HSV convertida em RGB com o alfa, multiplicado
      pela cor do vértice (boa prática para fazer isto sempre).</p>
    <p class="dropspot">Quanto ao nosso código de sorteio, ele é trivial no momento:</p>
    <p class="code">// Evento de desenho<br> <span class="notranslate">shader_set</span>(shdrRainbow);
      <br> draw_self();
      <br> <span class="notranslate">shader_reset</span>();
    </p>
    <p class="dropspot">Vamos ver o que temos:</p>
    <p class="dropspot"><img alt="Initial Rainbow Shader" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Rainbow_Overlay.gif">Estamos próximos do que queremos, mas há um problema: não estamos vendo todas as cores de uma só vez em todos os quadros
      da animação, e as cores parecem mudar aleatoriamente. A razão é que assumimos que <span class="inline">v_vTexcoord</span> nos deu as coordenadas do duende, começando no canto superior esquerdo (0,0) e terminando no canto inferior direito.
      (1,1), que é padrão em <span class="notranslate">shaders</span>. No entanto, para otimização, o <span class="notranslate">GameMaker</span> reúne o máximo de texturas que pode caber no que se chama uma <a href="../Settings/Texture_Information/Texture_Pages.htm">página de textura,</a> e por causa disso, esta
      é como nossa textura realmente é:</p>
    <p class="dropspot"><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Texture.png">Como explicado acima, <span class="inline">v_vTexcoord</span> nos dá as coordenadas absolutas do duende dentro de toda esta página de textura,
      mas o que queremos é um valor de 0,0 a 1,0 que cubra apenas nosso duende atual. Este processo é chamado de <strong>normalização</strong> (obter um valor e traduzi-lo para uma faixa de 0 a 1). Para normalizar nossos valores horizontais, precisamos saber o valor de
      valores de x0 e x1 na figura acima. Por sorte, o <span class="notranslate">GameMaker</span> tem uma função que nos dá a localização de cada canto de nosso sprite dentro da página de textura. Primeiro, precisamos ir até o Create Event e criar um uniforme para passar esses dados para
      o <span class="notranslate">sombreador</span>:</p>
    <p class="code">// Create Event<br> _uniUV = <span class="notranslate">shader_get_uniform</span>(shdrRainbow, &quot;u_uv&quot;);</p>
    <p class="dropspot">E modificamos o evento do sorteio para obter os valores e depois os passamos para o <span class="notranslate">sombreador</span>:</p>
    <p class="code">// Evento de desenho<br> <span class="notranslate">shader_set</span>(shdrRainbow);
      <br> var uv = sprite_get_uvs(sprite_index, image_index);<br> <span class="notranslate">shader_set_uniform_f</span>(_uniUV, uv[0], uv[2]);<br> draw_self();
      <br> <span class="notranslate">shader_reset</span>();
    </p>
    <p class="dropspot">A função <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a> pega um sprite e um índice, e devolve um array com toneladas de informações,
      tais como as coordenadas de cada canto, quantos pixels foram cortados para otimizá-lo, etc. Estamos interessados em dois desses valores: as coordenadas esquerda e direita do duende, que são armazenadas em <span class="inline">uv[0]</span> e <span class="inline">uv[2]</span>, respectivamente. No <span class="notranslate">shader</span> do fragmento, usaremos esses valores agora para calcular a posição horizontal normalizada desta forma:</p>
    <p class="code">// Fragment <span class="notranslate">Shader</span><br> variação vec2 v_vTexcoord;<br> variação vec4 v_vColour;<br>
      <br> vec2 u_uv uniforme;<br>
      <br> vec3 hsv2rgb(vec3 c) <br> {
      <br> vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br> vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br> return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br> }
      <br>
      <br> void main()<br> {
      <br> float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br> vec3 col = vec3(pos, 1.0, 1.0);<br> float alpha = text2D(gm_BaseTexture, v_vTexcoord).a;<br> gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br> }
    </p>
    <p class="dropspot">Aqui adicionamos a variável uniforme na parte superior do arquivo com o mesmo nome que usamos no Create Event. Em seguida, calculamos a posição horizontal normalizada, traduzindo nossa atual coordenada <span class="inline">x</span> para a origem (
      <span class="inline">v_vTexcoord.x - u_uv[0]</span> ) e depois a dividimos pela largura do duende para fazer o intervalo de 0 a 1 (<span class="inline">u_uv[1] - u_uv[0]</span>).</p>
    <p class="dropspot">O resultado é:</p>
    <p class="dropspot"><img alt="Rainbow Overlay Shader Improved" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Rainbow_Overlay_Improved.gif">Lá vamos nós! Isto é exatamente o que queríamos. Podemos ver todas as cores do espectro dentro
      nosso duende.</p>
    <p class="dropspot">Você pode ficar feliz com isso, mas podemos nos divertir um pouco mais com este <span class="notranslate">sombreador</span>. E se acrescentássemos uma compensação às cores com base no tempo para produzir movimento? Para fazer isso, precisaremos de duas variáveis extras para <strong>velocidade </strong>e <strong>tempo</strong>.
      Também precisaremos de mais dois uniformes, um para cada uma das novas variáveis, de modo que o Create Event se torne:</p>
    <p class="code">// Create Event<br> _uniUV = <span class="notranslate">shader_get_uniform</span>(shdrRainbow, &quot;u_uv&quot;);<br> _uniTime = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br> _uniSpeed = shader_get_uniform( <span class="notranslate">shdrRainbow</span>, &quot;u_speed&quot;);<br> _time = 0;<br> _speed = 1.0;</p>
    <p class="dropspot">Também precisamos aumentar o tempo a cada quadro, por isso, no Evento de Etapa, acrescentamos:</p>
    <p class="code">// Step Event<br> _time += 1 / room_speed;</p>
    <p class="dropspot">Vamos agora ao evento do sorteio para enviar estes uniformes para o <span class="notranslate">shader</span>:</p>
    <p class="code">// Evento de desenho<br> <span class="notranslate">shader_set</span>(shdrRainbow);
      <br> var uv = sprite_get_uvs(sprite_index, image_index);<br> <span class="notranslate">shader_set_uniform_f</span>(_uniUV, uv[0], uv[2]);<br> <span class="notranslate">shader_set_uniform_f</span>(_uniSpeed, _speed);<br> <span class="notranslate">shader_set_uniform_f</span>(_uniTime, _time);<br> draw_self();
      <br> <span class="notranslate">shader_reset</span>();
    </p>
    <p class="dropspot">Finalmente, voltaremos ao nosso shader <span class="notranslate">para</span> usar realmente estas variáveis agora. O que faremos é multiplicar a velocidade com o tempo e adicioná-la à posição, desta forma:</p>
    <p class="code">// Fragment <span class="notranslate">Shader</span><br> variação vec2 v_vTexcoord;<br> variação vec4 v_vColour;<br>
      <br> vec2 u_uv uniforme;<br> flutuação uniforme u_speed;<br> flutuação uniforme u_time;<br>
      <br> vec3 hsv2rgb(vec3 c) <br> {
      <br> vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br> vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br> return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br> }
      <br>
      <br> main()<br> {
      <br> float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br> vec3 col = vec3((u_time * u_speed) + pos, 1.0, 1.0);<br> float alpha = text2D(gm_BaseTexture, v_vTexcoord).a;<br> gl_FragColor = v_vColour * vec4(hsv2rgb(col),
      alfa);
      <br> }
    </p>
    <p class="dropspot">Se você fez tudo corretamente, você deveria estar vendo algo assim:</p>
    <p class="dropspot"><img alt="Rainbow Shader Overlay Moving With Time" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Rainbow_Overlay_Final.gif">Para terminar este <span class="notranslate">shader</span>, acrescentaremos mais alguns uniformes para personalizá-lo ainda mais.
      Os dois primeiros são para controlar a saturação e a luminosidade. O próximo chamamos &quot;seção&quot; e sua função é permitir que o usuário passe um número entre zero e um para determinar que porcentagem de todo o espectro vemos em
      um tempo. Por último, adicionaremos uma variável chamada &quot;mix&quot;, que especificará o quanto queremos misturar nossa <span class="notranslate">cor de</span> sombreamento com a cor da textura original (1,0 é tudo arco-íris, 0,0 é tudo textura). Como sempre, vamos começar adicionando as variáveis a
      o Evento Criar:</p>
    <p class="code">// Create Event<br> _uniUV = <span class="notranslate">shader_get_uniform</span>(shdrRainbow, &quot;u_uv&quot;);<br> _uniTime = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br> _uniSpeed = shader_get_uniform( <span class="notranslate">shdrRainbow</span>, &quot;u_speed&quot;);<br> _uniSection
         = <span class="notranslate">shader_get_uniform</span>(shdrRainbow, &quot;u_section&quot;);<br> _uniSaturação = shader_get_uniform(shdrRainbow, &quot;u_saturação&quot;); <br> _uniBrightness = shader_get_uniform( <span class="notranslate">shdrRainbow</span>, &quot;u_brightness&quot;);<br> _uniMix =
     <span class="notranslate">shader_get_uniform</span>(shdrRainbow, &quot;u_mix&quot;);<br>
      <br> _time = 0;<br> _speed = 1,0;<br> _section = 0,5;<br> _saturation = 0,7;<br> _brightness = 0,8;<br> _mix = 0,5;</p>
    <p class="dropspot">Nosso evento de sorteio muda para incluir estes uniformes como este:</p>
    <p class="code">// Evento de desenho<br> <span class="notranslate">shader_set</span>(shdrRainbow);
      <br> var uv = sprite_get_uvs(sprite_index, image_index);<br> <span class="notranslate">shader_set_uniform_f</span>(_uniUV, uv[0], uv[2]);<br> <span class="notranslate">shader_set_uniform_f</span>(_uniSpeed, _speed);<br> <span class="notranslate">shader_set_uniform_f</span>(_uniTime, _time); <br> <span class="notranslate">shader_set_uniform_f</span>(_uniSaturação, _saturação);<br> <span class="notranslate">shader_set_uniform_f</span>(_uniBrightness, _brightness);<br> <span class="notranslate">shader_set_uniform_f</span>(_uniSection, _section);<br> <span class="notranslate">shader_set_uniform_f</span>(_uniMix, _mix);<br> draw_self();
      <br> <span class="notranslate">shader_reset</span>();
    </p>
    <p class="dropspot">Quanto ao <span class="notranslate">sombreador</span>, precisamos passar a saturação e o brilho para a cor, o que afetará a cor gerada por nossa função auxiliar. A seção precisa ser multiplicada pela nossa posição para reduzir o alcance. Também vamos agarrar toda a textura
      para que possamos calcular nossa cor final, misturando a cor da textura com a conversão RGB de nossa cor. O último parâmetro da função de mistura determina a quantidade da segunda cor que queremos adicionar. Este é nosso código final de <span class="notranslate">sombreamento</span>:</p>
    <p class="code">// Fragment <span class="notranslate">Shader</span><br> variação vec2 v_vTexcoord;<br> variação vec4 v_vColour;<br>
      <br> flutuação uniforme vec2 u_uv;<br> flutuação uniforme u_speed;<br> flutuação uniforme u_time;<br> flutuação uniforme u_saturação;<br> flutuação uniforme u_brightness;<br> flutuação uniforme u_section;<br> flutuação uniforme u_mix;<br>
      <br> vec3 hsv2rgb(vec3 c) <br> {
      <br> vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br> vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br> return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br> }
      <br>
      <br> void main()<br> {
      <br> float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br> vec4 texColor = textura2D(gm_BaseTexture, v_vTexcoord); <br>     <br> vec3 col = vec3(u_section * ((u_time * u_speed) + pos), u_saturação, u_brightness);<br> vec4 finalCol = mix(texColor, vec4(hsv2rgb(col), texColor.a), u_mix);<br>     <br> gl_FragColor = v_vColour * finalCol;<br> }
    </p>
    <p class="dropspot">E nosso resultado final é este!</p>
    <p class="dropspot"><img alt="Rainbow Shader Final" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Rainbow_Final.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Esse é o fim deste pequeno guia e agora você deve ter uma melhor compreensão de como funcionam os shaders e alguns dos usos que eles podem ser dados. Você deve dedicar seu tempo para brincar com os <span class="notranslate">shaders</span> que você criou seguindo este guia, e tentar
    experimente com eles fazer outras coisas - que tal criar um <span class="notranslate">sombreador de</span> borrão, ou um <span class="notranslate">sombreador</span> que faça uma tela monocromática estilo gameboy? - uma vez que <span class="notranslate">os shaders</span> são uma ferramenta incrivelmente poderosa para acrescentar complexidade visual e estilo aos seus jogos.</p>
  <p> </p>
  <p class="note"><span class="notranslate">YoYo Games</span> gostaria de agradecer a <a href="https://twitter.com/AleHitti">Alejandro Hitti</a> e <strong><span class="notranslate">Amazônia</span></strong> por nos permitir reproduzir este guia. Você pode encontrar a versão original no <a href="https://developer.amazon.com/es/blogs/appstore/post/acefafad-29ba-4f31-8dae-00805fda3f58/intro-to-shaders-and-surfaces-with-gamemaker-studio-2">Blog</a> da <a href="https://developer.amazon.com/es/blogs/appstore/post/acefafad-29ba-4f31-8dae-00805fda3f58/intro-to-shaders-and-surfaces-with-gamemaker-studio-2"><span class="notranslate">Amazon</span></a> Developer.</p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Voltar: <a href="Additional_Information.htm">Informações adicionais</a></div>
        <div style="float:right">A seguir: <a href="Guide_To_Primitives_And_Vertex_Building.htm">Guia de Primitivos e Construção de Vértices</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Todos os direitos reservados</span></h5>
  </div>
  <!-- KEYWORDS
<span class="notranslate">Shaders</span>
Using <span class="notranslate">Shaders</span>
<span class="notranslate">Shader</span> Guide
Guide To Using <span class="notranslate">Shaders</span>
-->
  <!-- TAGS
using_<span class="notranslate">shaders</span>
-->
</body>
</html>