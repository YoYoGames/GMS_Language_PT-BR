<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Buffers</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Reference section for the Buffer functions" />
  <meta name="rh-index-keywords" content="" />
  <meta name="search-keywords" content="Buffers" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Buffers</h1>
  <p>Um buffer é uma região da memória física usada para armazenar temporariamente dados enquanto estão sendo movidos de um lugar para outro ou manipulados de alguma forma, por exemplo, você pode usar um buffer para armazenar dados de pacotes que aguardam transmissão por uma rede ou para armazenar
    um pacote que foi recebido através de uma rede. O <span class="notranslate">GameMaker Studio 2</span> tem uma série de funções específicas relacionadas à criação, modificação e carregamento/reserva de buffers, mas antes de utilizá-los, observe os seguintes pontos:</p>
  <ul class="colour">
    <li>Quando um buffer é criado, ele é automaticamente limpo e preenchido a 0.</li>
    <li>O argumento do &quot;tamanho&quot; das funções do buffer sempre se refere ao tamanho em bytes <i>do</i> buffer.</li>
    <li>O argumento &quot;Alinhamento&quot; refere-se a como os dados são armazenados dentro de um buffer. Se seu alinhamento for definido para dizer, 4, e você escrever um único pedaço de dados que seja 1 byte em tamanho, então faça um <tt>buffer_tell</tt>, você terá um offset de 1,
      se você escrever outro dado, também 1 byte em tamanho, então faça um <tt>buffer_tell</tt>, você terá um offset de 5, pois o alinhamento &quot;almofadou&quot; os dados para aquele tamanho. O alinhamento só afeta para <i>onde</i> as coisas são escritas, portanto, se
      você faz um <tt>buffer_tell</tt> depois de escrever algo, ele retornará a posição de escrita atual que imediatamente segue os dados que você escreveu. Observe, entretanto, que se você escrever outro dado, internamente o buffer se moverá
      a posição de escrita ao longo do próximo múltiplo do tamanho do alinhamento antes de realmente escrever a peça de dados.</li>
    <li>Quando se trata de &quot;offset&quot;, este é o valor em bytes <i>para compensar</i> os dados por dentro do buffer dado. Portanto, se seu buffer estiver 2 bytes alinhado e você quiser pular os 4 primeiros lugares alinhados, você teria um offset de <tt>2 * 4 bytes</tt>.</li>
    <li>Algumas das funções do buffer também criam um novo buffer (como <tt>buffer_load</tt>, por exemplo). Lembre-se de que estes buffers também precisarão ser removidos da memória quando não estiverem em uso usando a função <tt>buffer_delete</tt>.</li>
    <li>A memória utilizada para criar buffers é a <i>memória do sistema</i>, portanto, mesmo quando o jogo não tem foco, qualquer dado armazenado em um buffer deve ser seguro, entretanto, se o aplicativo for fechado ou reiniciado, ele será perdido.</li>
  </ul>
  <p>As páginas seguintes explicam como funcionam os buffers dentro do contexto do <span class="notranslate">GameMaker Studio 2</span> e contêm alguns exemplos de código para aqueles usuários que não têm certeza de como utilizá-los:</p>
  <ul class="colour">
    <li><a href="../../../Additional_Information/Guide_To_Using_Buffers.htm">Usando amortecedores</a></li>
  </ul>
  <p class="note"><em><strong>IMPORTANTE!</strong></em> Quando você cria um buffer, o valor do índice usado para identificá-lo é um valor inteiro começando em 0. Estes índices são reutilizados pelo <span class="notranslate">GameMaker</span>, portanto, um valor de índice de buffer destruído pode ser usado por um novo valor criado posteriormente,
    e recomendamos que você defina qualquer variável que contenha um índice de tampão para -1 após ter destruído o tampão.</p>
  <p>As seguintes funções existem para você usar com buffers binários em seus jogos:</p>
  <ul class="colour">
    <li><a href="buffer_exists.htm">buffer_existe</a></li>
    <li><a href="buffer_create.htm">buffer_create</a></li>
    <li><a href="buffer_create_from_vertex_buffer.htm">buffer_create_from_vertex_buffer</a></li>
    <li><a href="buffer_create_from_vertex_buffer_ext.htm">buffer_create_from_vertex_buffer_ext</a></li>
    <li><a href="buffer_delete.htm">buffer_delete</a></li>
    <li><a href="buffer_read.htm">buffer_read</a></li>
    <li><a href="buffer_write.htm">buffer_write</a></li>
    <li><a href="buffer_fill.htm">buffer_fill</a></li>
    <li><a href="buffer_seek.htm">tampão_seek</a></li>
    <li><a href="buffer_tell.htm">buffer_tell</a></li>
    <li><a href="buffer_peek.htm">tampão_peek</a></li>
    <li><a href="buffer_poke.htm">ponto_de_tampão</a></li>
    <li><a href="buffer_save.htm">buffer_save</a></li>
    <li><a href="buffer_save_ext.htm">buffer_save_ext_ext</a></li>
    <li><a href="buffer_save_async.htm">buffer_save_async</a></li>
    <li><a href="buffer_load.htm">buffer_load</a></li>
    <li><a href="buffer_load_ext.htm">buffer_load_ext_ext</a></li>
    <li><a href="buffer_load_async.htm">buffer_load_async</a></li>
    <li><a href="buffer_load_partial.htm">buffer_load_partial</a></li>
    <li><a href="buffer_compress.htm">buffer_compress</a></li>
    <li><a href="buffer_decompress.htm">buffer_decompress</a></li>
    <li><a href="buffer_async_group_begin.htm">buffer_async_group_begin</a></li>
    <li><a href="buffer_async_group_option.htm">opção_de_tampão_async_group_option</a></li>
    <li><a href="buffer_async_group_end.htm">buffer_async_group_end</a></li>
    <li><a href="buffer_copy.htm">buffer_copy</a></li>
    <li><a href="buffer_copy_from_vertex_buffer.htm">buffer_copy_from_vertex_buffer</a></li>
    <li><a href="buffer_get_type.htm">tipo_computador</a></li>
    <li><a href="buffer_get_alignment.htm">buffer_get_alignment</a></li>
    <li><a href="buffer_get_address.htm">endereço_de_suporte</a></li>
    <li><a href="buffer_get_size.htm">tamanho_do_tampão_de_servidor</a></li>
    <li><a href="buffer_get_surface.htm">superfície_de_solução</a></li>
    <li><a href="buffer_set_surface.htm">superfície_superfície_de_tampão</a></li>
    <li><a href="buffer_resize.htm">tamanho_tampão</a></li>
    <li><a href="buffer_sizeof.htm">tamanho_do_tampão</a></li>
    <li><a href="buffer_md5.htm">buffer_md5</a></li>
    <li><a href="buffer_sha1.htm">buffer_sha1</a></li>
    <li><a href="buffer_crc32.htm">buffer_crc32</a></li>
    <li><a href="buffer_base64_encode.htm">base64_código_de_tampão</a></li>
    <li><a href="buffer_base64_decode.htm">buffer_base64_decode</a></li>
    <li><a href="buffer_base64_decode_ext.htm">buffer_base64_decode_ext</a></li>
    <li><a href="buffer_set_used_size.htm">tamanho_utilizado_do_soltampão</a></li>
  </ul>
  <p> </p>
  <p>Há também duas funções extras relacionadas aos amortecedores que podem ser usadas para salvar e carregar estados de jogo (note que eles requerem que um amortecedor tenha sido criado anteriormente):</p>
  <p> </p>
  <ul class="colour">
    <li><a href="../General_Game_Control/game_load_buffer.htm">jogo_load_buffer</a></li>
    <li><a href="../General_Game_Control/game_save_buffer.htm">jogo_save_buffer</a></li>
  </ul>
  <p> </p>
  <p>Finalmente, você também pode usar <b>amortecedores de vértices</b> especiais para criar seus próprios primitivos ou modelos personalizados, etc... Você pode saber mais sobre eles na seção seguinte do manual:</p>
  <p> </p>
  <ul class="colour">
    <li><a href="../Drawing/Primitives/Primitives_And_Vertex_Formats.htm">Edifício Primitivo</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Voltar: <a href="../GML_Reference.htm">Referência<span class="notranslate">GML</span></a></div>
        <div style="float:right">A seguir: <a href="../UWP_And_XBox_Live/UWP_And_XBox_Live.htm">UWP e XBox Live</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Todos os direitos reservados</span></h5>
  </div>
  <!-- KEYWORDS
Buffers
-->
  <!-- TAGS
buffer_functions
-->
</body>
</html>